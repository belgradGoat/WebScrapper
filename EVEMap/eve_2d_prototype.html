<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EVE Online 2D Universe Map</title>
    <link rel="stylesheet" href="eve-map-styles.css">
    <script src="eve-api-client.js"></script>
    <script src="eve-region-layout.js"></script>
    <script src="eve-region-detail-layout-engine.js"></script>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <h1>⚡ EVE Universe Map</h1>
            <div class="header-controls">
                <button class="btn" id="backToRegionsBtn" onclick="map.showRegionsView()" style="display: none;">← Back to Regions</button>
                <input type="text" class="search-box" id="searchInput" placeholder="Search system or region...">
                <button class="btn" id="resetViewBtn">Reset View</button>
            </div>
        </header>
        
        <aside class="sidebar-left scrollbar">
            <div class="panel">
                <div class="panel-header">Navigation</div>
                <div class="panel-content">
                    <div class="filter-tabs">
                        <div class="filter-tab active" data-filter="regions">Regions</div>
                        <div class="filter-tab" data-filter="route">Route</div>
                    </div>
                    
                    <div id="regionsPanel">
                        <div class="region-list scrollbar" id="regionList">
                            <!-- Regions will be populated here -->
                        </div>
                    </div>
                    
                    <div id="routePanel" style="display: none;">
                        <div class="route-inputs">
                            <input type="text" id="routeFrom" placeholder="Origin system..." class="search-box">
                            <input type="text" id="routeTo" placeholder="Destination system..." class="search-box">
                            <button class="btn" onclick="map.planRouteFromInputs()">Calculate Route</button>
                            <button class="btn btn-danger" onclick="map.clearRoute()">Clear Route</button>
                        </div>
                        
                        <div class="stat-item">
                            <span class="stat-label">Total Jumps:</span>
                            <span class="stat-value" id="totalJumps">0</span>
                        </div>
                        
                        <div style="max-height: 300px; overflow-y: auto;" class="scrollbar">
                            <div id="routeSteps">
                                <div class="route-step">
                                    <span>Enter systems above to plan route</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <div class="panel-header">Legend</div>
                <div class="panel-content">
                    <div class="security-legend">
                        <div class="security-dot" style="background: #00ff00; box-shadow: 0 0 5px #00ff00;"></div>
                        High-Sec (1.0 - 0.5)
                    </div>
                    <div class="security-legend">
                        <div class="security-dot" style="background: #ffff00; box-shadow: 0 0 5px #ffff00;"></div>
                        Low-Sec (0.4 - 0.1)
                    </div>
                    <div class="security-legend">
                        <div class="security-dot" style="background: #ff4444; box-shadow: 0 0 5px #ff4444;"></div>
                        Null-Sec (0.0 - -1.0)
                    </div>
                    <div class="security-legend">
                        <div class="security-dot" style="background: #ff00ff; box-shadow: 0 0 5px #ff00ff;"></div>
                        Wormhole Space
                    </div>
                </div>
            </div>
        </aside>
        
        <main class="map-container">
            <canvas class="map-canvas" id="mapCanvas"></canvas>
            
            <div class="loading-overlay" id="loadingOverlay">
                <div class="spinner"></div>
                <div style="color: #00d4ff; font-size: 18px; margin-bottom: 10px;">Loading Universe Data</div>
                <div id="loadingProgress" style="color: #aaa;">Initializing...</div>
            </div>
        </main>
        
        <aside class="sidebar-right scrollbar">
            <div class="panel">
                <div class="panel-header">System Information</div>
                <div class="panel-content">
                    <div id="systemInfo">
                        <div style="text-align: center; color: #666; padding: 20px;">
                            Click on a system to view details
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="panel" id="searchResultsPanel" style="display: none;">
                <div class="panel-header">Search Results</div>
                <div class="panel-content">
                    <div id="searchResults" style="max-height: 200px; overflow-y: auto;"></div>
                </div>
            </div>
            
            <div class="panel">
                <div class="panel-header">Activity Statistics</div>
                <div class="panel-content">
                    <div class="stat-item">
                        <span class="stat-label">Ship Kills (24h):</span>
                        <span class="stat-value" id="shipKills">--</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Pod Kills (24h):</span>
                        <span class="stat-value" id="podKills">--</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Jumps (1h):</span>
                        <span class="stat-value" id="systemJumps">--</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Activity Level:</span>
                        <div>
                            <div class="activity-bar">
                                <div class="activity-fill" id="activityFill" style="width: 0%;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <div class="panel-header">Map Controls</div>
                <div class="panel-content">
                    <div class="controls-grid">
                        <button class="btn" onclick="map.zoomIn()">Zoom In</button>
                        <button class="btn" onclick="map.zoomOut()">Zoom Out</button>
                        <button class="btn" onclick="map.toggleConnections()">Toggle Gates</button>
                        <button class="btn" onclick="map.toggleLabels()">Toggle Labels</button>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Show Connections:</span>
                        <span class="stat-value" id="showConnections">Yes</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Show Labels:</span>
                        <span class="stat-value" id="showLabels">Auto</span>
                    </div>
                </div>
            </div>
        </aside>
        
        <footer class="footer">
            <span>EVE Online Universe Map | Systems Loaded: <span id="systemCount">0</span> | 
            Zoom: <span id="zoomLevel">100%</span> | 
            Selected: <span id="selectedSystemName">None</span></span>
            <div style="margin-left: auto;">
                <span>Data from FastAPI Backend</span>
            </div>
        </footer>
    </div>

    <script>
// Then your EVEUniverseMap2D class continues as before...
        // Main EVE Universe Map Class - Updated to use FastAPI backend and cached data
        class EVEUniverseMap2D {
            constructor() {
                        // Add this line at the very beginning
        this.canvas = document.getElementById('mapCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Initialize API client with FastAPI backend URL
        this.api = new EVEAPIClient({
            proxyURL: 'http://localhost:3001/api'
        });
                
                this.systems = [];
                this.regions = [];
                this.connections = [];
                this.systemKills = new Map();
                this.systemJumps = new Map();
                this.highlightedSystems = [];
                
                this.scale = 1;
                this.offsetX = 0;
                this.offsetY = 0;
                this.isDragging = false;
                this.lastX = 0;
                this.lastY = 0;
                
                this.selectedSystem = null;
                this.hoveredSystem = null;
                this.hoveredRegion = null;
                this.currentRoute = [];
                this.routeStart = null;
                this.routeEnd = null;
                
                this.showConnections = true;
                this.showLabels = 'auto';
                
                this.selectedRegion = null;
                this.viewMode = 'regions';
                this.universeData = null;
                
                this.init();
            }
            
            init() {
                this.setupCanvas();
                this.setupEventListeners();
                this.loadUniverseData();
            }
            
            setupCanvas() {
                const resize = () => {
                    this.canvas.width = this.canvas.offsetWidth;
                    this.canvas.height = this.canvas.offsetHeight;
                    this.draw();
                };
                
                window.addEventListener('resize', resize);
                resize();
            }
            
            drawRegionDetail() {
    if (!this.regionLayout) return;
    
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    const scale = this.scale;
    
    // Draw constellation boundaries with subway-style boxes
    this.regionLayout.forEach((constLayout, constId) => {
        const x = centerX + (constLayout.x - this.canvas.width * 0.4) * scale + this.offsetX;
        const y = centerY + (constLayout.y - this.canvas.height * 0.4) * scale + this.offsetY;
        const width = constLayout.width * scale;
        const height = constLayout.height * scale;
        
        // Draw constellation container
        this.ctx.fillStyle = 'rgba(20, 20, 30, 0.8)';
        this.ctx.strokeStyle = 'rgba(0, 212, 255, 0.3)';
        this.ctx.lineWidth = 2;
        
        // Draw rounded rectangle with thicker borders
        this.drawRoundedRect(x - width/2, y - height/2, width, height, 15);
        this.ctx.fill();
        this.ctx.stroke();
        
        // Draw constellation name as station label
        const constellation = this.getConstellationData(constId);
        if (constellation && scale > 0.5) {
            // Background for label
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            const labelWidth = this.ctx.measureText(constellation.name).width + 20;
            this.drawRoundedRect(x - labelWidth/2, y - height/2 - 25, labelWidth, 30, 5);
            this.ctx.fill();
            
            // Label text
            this.ctx.fillStyle = '#00d4ff';
            this.ctx.font = `bold ${Math.max(14, 16 * scale)}px Consolas`;
            this.ctx.textAlign = 'center';
            this.ctx.fillText(constellation.name, x, y - height/2 - 5);
        }
    });
    
    // Draw all connections first (behind systems)
    this.drawSubwayConnections();
    
    // Then draw systems on top
    this.drawSubwaySystems();
}

drawSubwayConnections() {
    if (!this.regionConnections || !this.regionLayout) return;
    
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    const scale = this.scale;
    
    // Group connections by type
    const intraConnections = [];
    const interConnections = [];
    
    this.regionConnections.forEach(conn => {
        if (conn.from.constId === conn.to.constId) {
            intraConnections.push(conn);
        } else {
            interConnections.push(conn);
        }
    });
    
    // Draw intra-constellation connections first
    this.ctx.lineCap = 'round';
    this.ctx.lineJoin = 'round';
    
    intraConnections.forEach(conn => {
        const fromConst = this.regionLayout.get(conn.from.constId);
        const toConst = this.regionLayout.get(conn.to.constId);
        
        if (fromConst && toConst && fromConst.systems && toConst.systems) {
            const fromSystem = fromConst.systems.get(conn.from.systemId);
            const toSystem = toConst.systems.get(conn.to.systemId);
            
            if (fromSystem && toSystem) {
                const x1 = centerX + (fromConst.x - this.canvas.width * 0.4 + fromSystem.x - fromConst.width/2) * scale + this.offsetX;
                const y1 = centerY + (fromConst.y - this.canvas.height * 0.4 + fromSystem.y - fromConst.height/2) * scale + this.offsetY;
                const x2 = centerX + (toConst.x - this.canvas.width * 0.4 + toSystem.x - toConst.width/2) * scale + this.offsetX;
                const y2 = centerY + (toConst.y - this.canvas.height * 0.4 + toSystem.y - toConst.height/2) * scale + this.offsetY;
                
                // Draw subway-style connection
                this.drawSubwayLine(x1, y1, x2, y2, fromSystem.system.security_status);
            }
        }
    });
    
    // Draw inter-constellation connections with special styling
    this.ctx.save();
    this.ctx.setLineDash([15, 10]);
    this.ctx.lineCap = 'round';
    
    interConnections.forEach(conn => {
        const fromConst = this.regionLayout.get(conn.from.constId);
        const toConst = this.regionLayout.get(conn.to.constId);
        
        if (fromConst && toConst && fromConst.systems && toConst.systems) {
            const fromSystem = fromConst.systems.get(conn.from.systemId);
            const toSystem = toConst.systems.get(conn.to.systemId);
            
            if (fromSystem && toSystem) {
                const x1 = centerX + (fromConst.x - this.canvas.width * 0.4 + fromSystem.x - fromConst.width/2) * scale + this.offsetX;
                const y1 = centerY + (fromConst.y - this.canvas.height * 0.4 + fromSystem.y - fromConst.height/2) * scale + this.offsetY;
                const x2 = centerX + (toConst.x - this.canvas.width * 0.4 + toSystem.x - toConst.width/2) * scale + this.offsetX;
                const y2 = centerY + (toConst.y - this.canvas.height * 0.4 + toSystem.y - toConst.height/2) * scale + this.offsetY;
                
                // Inter-constellation lines are thicker and dashed
                const avgSec = (fromSystem.system.security_status + toSystem.system.security_status) / 2;
                this.drawSubwayLine(x1, y1, x2, y2, avgSec, true);
            }
        }
    });
    
    this.ctx.restore();
}

drawSubwayLine(x1, y1, x2, y2, secStatus, isInterConst = false) {
    // Determine line color based on security - subway line colors
    let lineColor = '#666666';
    let lineWidth = 5;
    
    if (secStatus >= 0.5) {
        lineColor = '#00ff00'; // Green line for high-sec
    } else if (secStatus >= 0.1) {
        lineColor = '#ffaa00'; // Orange/yellow line for low-sec
    } else {
        lineColor = '#ff4444'; // Red line for null-sec
    }
    
    // Inter-constellation connections are thicker
    if (isInterConst) {
        lineWidth = 7;
        lineColor = '#ffd700'; // Gold color for transfers
    }
    
    this.ctx.strokeStyle = lineColor;
    this.ctx.lineWidth = lineWidth * (this.scale > 1 ? 1 : 0.8);
    
    // Add subtle glow for better visibility
    if (this.scale > 0.8) {
        this.ctx.shadowColor = lineColor;
        this.ctx.shadowBlur = 10;
    }
    
    // Draw curved subway-style lines
    const dx = x2 - x1;
    const dy = y2 - y1;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    this.ctx.beginPath();
    this.ctx.moveTo(x1, y1);
    
    if (distance > 100) {
        // For longer distances, use bezier curves like subway maps
        if (Math.abs(dx) > Math.abs(dy)) {
            // Horizontal-dominant connection
            const cpx = x1 + dx * 0.5;
            this.ctx.bezierCurveTo(cpx, y1, cpx, y2, x2, y2);
        } else {
            // Vertical-dominant connection
            const cpy = y1 + dy * 0.5;
            this.ctx.bezierCurveTo(x1, cpy, x2, cpy, x2, y2);
        }
    } else {
        // Short connections are straight
        this.ctx.lineTo(x2, y2);
    }
    
    this.ctx.stroke();
    this.ctx.shadowBlur = 0;
}

drawSubwaySystems() {
    if (!this.regionLayout) return;
    
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    const scale = this.scale;
    
    this.regionLayout.forEach((constLayout, constId) => {
        const constX = centerX + (constLayout.x - this.canvas.width * 0.4) * scale + this.offsetX;
        const constY = centerY + (constLayout.y - this.canvas.height * 0.4) * scale + this.offsetY;
        
        constLayout.systems.forEach((systemLayout, systemId) => {
            const sysX = constX + (systemLayout.x - constLayout.width/2) * scale;
            const sysY = constY + (systemLayout.y - constLayout.height/2) * scale;
            
            const system = systemLayout.system;
            if (!system) return;
            
            // Determine station style based on security
            const secStatus = system.security_status || 0;
            let stationColor = this.getSecurityColor(secStatus);
            let stationStyle = 'standard';
            
            // Check if it's a hub (multiple connections)
            if (systemLayout.radius > 10) stationStyle = 'hub';
            if (systemLayout.radius < 7) stationStyle = 'terminal';
            
            // Draw station circle - subway station style
            const radius = systemLayout.radius * scale;
            
            // Outer white ring for all stations
            this.ctx.fillStyle = '#ffffff';
            this.ctx.beginPath();
            this.ctx.arc(sysX, sysY, radius + 3, 0, Math.PI * 2);
            this.ctx.fill();
            
            // Main station circle
            this.ctx.fillStyle = '#1a1a2e';
            this.ctx.strokeStyle = stationColor;
            this.ctx.lineWidth = 4;
            
            this.ctx.beginPath();
            this.ctx.arc(sysX, sysY, radius, 0, Math.PI * 2);
            this.ctx.fill();
            this.ctx.stroke();
            
            // Inner indicator for main route stations
            if (systemLayout.onMainRoute) {
                this.ctx.fillStyle = stationColor;
                this.ctx.beginPath();
                this.ctx.arc(sysX, sysY, radius * 0.4, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            // Station name label - always visible for important stations
            if (scale > 0.8 || stationStyle === 'hub' || systemLayout.onMainRoute) {
                const label = system.name;
                const fontSize = Math.max(10, 12 * scale);
                this.ctx.font = `bold ${fontSize}px Arial`;
                
                // Measure text for background
                const metrics = this.ctx.measureText(label);
                const labelWidth = metrics.width + 10;
                const labelHeight = fontSize + 6;
                
                // Position label below station
                const labelX = sysX - labelWidth/2;
                const labelY = sysY + radius + 8;
                
                // Draw label background
                this.ctx.fillStyle = 'rgba(26, 26, 46, 0.95)';
                this.ctx.strokeStyle = stationColor;
                this.ctx.lineWidth = 1;
                
                this.drawRoundedRect(labelX, labelY, labelWidth, labelHeight, 3);
                this.ctx.fill();
                this.ctx.stroke();
                
                // Draw label text
                this.ctx.fillStyle = '#ffffff';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(label, sysX, labelY + labelHeight/2);
            }
            
            // Hover effect
            if (this.hoveredSystem === system || this.selectedSystem === system) {
                this.ctx.strokeStyle = '#00d4ff';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.arc(sysX, sysY, radius + 8, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                // Show security badge on hover
                const badgeX = sysX + radius + 5;
                const badgeY = sysY - radius - 5;
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                this.ctx.strokeStyle = stationColor;
                this.ctx.lineWidth = 2;
                
                this.drawRoundedRect(badgeX, badgeY, 45, 22, 3);
                this.ctx.fill();
                this.ctx.stroke();
                
                this.ctx.fillStyle = stationColor;
                this.ctx.font = 'bold 12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(secStatus.toFixed(1), badgeX + 22, badgeY + 13);
            }
        });
    });
}

// Also make sure to add the missing getSecurityColor method if it doesn't exist:
getSecurityColor(secStatus) {
    if (secStatus >= 0.5) return '#00ff00';
    else if (secStatus >= 0.1) return '#ffaa00';
    else if (secStatus >= 0.0) return '#ff8800';
    else return '#ff4444';
}

            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('wheel', this.handleWheel.bind(this));
                this.canvas.addEventListener('click', this.handleClick.bind(this));
                
                // Search with debounce
                let searchTimeout;
                const searchInput = document.getElementById('searchInput');
                searchInput.addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    const query = e.target.value.trim();
                    
                    if (query.length >= 2) {
                        searchTimeout = setTimeout(() => {
                            this.searchSystemFromAPI(query);
                        }, 300);
                    } else {
                        this.highlightedSystems = [];
                        this.hideSearchResults();
                        this.draw();
                    }
                });
                
                // Reset view
                document.getElementById('resetViewBtn').addEventListener('click', () => {
                    this.resetView();
                });
                
                // Filter tabs
                document.querySelectorAll('.filter-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        this.switchTab(e.target.dataset.filter);
                    });
                });
            }

            showRegionDetail(region) {
    this.viewMode = 'region-detail';
    this.selectedRegion = region;
    this.selectedConstellation = null;
    
    // Load region detail data
    this.loadRegionDetail(region);
    
    // Update UI
    document.getElementById('backToRegionsBtn').style.display = 'block';
    this.updateRegionDetailPanel();
}

async loadRegionDetail(region) {
    try {
        // Show loading
        this.showLoading('Loading region details...');
        
        // Get region data from cache or API
        const regionData = await this.getRegionDetailData(region.id);
        
        // Create schematic layout
        const layout = new RegionDetailLayout();
        this.regionLayout = layout.layoutRegion(
            regionData, 
            this.canvas.width * 0.8, 
            this.canvas.height * 0.8
        );
        
        // Calculate connections
        this.regionConnections = layout.calculateConnections(regionData, this.regionLayout);
        
        this.hideLoading();
        this.draw();
        
    } catch (error) {
        console.error('Failed to load region detail:', error);
        this.hideLoading();
    }
}

drawRegionConnections() {
    if (!this.regionConnections) return;
    
    this.ctx.strokeStyle = 'rgba(0, 212, 255, 0.2)';
    this.ctx.lineWidth = 1;
    
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    const scale = this.scale;
    
    // Draw inter-constellation connections with bezier curves
    const drawnConnections = new Set();
    
    this.regionConnections.forEach(conn => {
        // Avoid duplicate connections
        const connKey = `${conn.from.constId}-${conn.to.constId}`;
        const reverseKey = `${conn.to.constId}-${conn.from.constId}`;
        
        if (drawnConnections.has(connKey) || drawnConnections.has(reverseKey)) {
            return;
        }
        
        drawnConnections.add(connKey);
        
        if (conn.from.constId !== conn.to.constId) {
            // Inter-constellation connection
            const fromConst = this.regionLayout.get(conn.from.constId);
            const toConst = this.regionLayout.get(conn.to.constId);
            
            if (fromConst && toConst) {
                const x1 = centerX + (fromConst.x - this.canvas.width * 0.4) * scale + this.offsetX;
                const y1 = centerY + (fromConst.y - this.canvas.height * 0.4) * scale + this.offsetY;
                const x2 = centerX + (toConst.x - this.canvas.width * 0.4) * scale + this.offsetX;
                const y2 = centerY + (toConst.y - this.canvas.height * 0.4) * scale + this.offsetY;
                
                // Draw curved connection
                this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                const curve = 50 * scale;
                
                this.ctx.moveTo(x1, y1);
                this.ctx.quadraticCurveTo(midX, midY - curve, x2, y2);
                this.ctx.stroke();
            }
        }
    });
}

drawRoundedRect(x, y, width, height, radius) {
    this.ctx.beginPath();
    this.ctx.moveTo(x + radius, y);
    this.ctx.lineTo(x + width - radius, y);
    this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    this.ctx.lineTo(x + width, y + height - radius);
    this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    this.ctx.lineTo(x + radius, y + height);
    this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    this.ctx.lineTo(x, y + radius);
    this.ctx.quadraticCurveTo(x, y, x + radius, y);
    this.ctx.closePath();
}

updateRegionDetailPanel() {
    const regionList = document.getElementById('regionList');
    regionList.innerHTML = '';
    
    if (this.selectedRegion && this.regionLayout) {
        // Add region title with subway map styling
        const title = document.createElement('div');
        title.className = 'panel-section-title';
        title.style.background = 'linear-gradient(90deg, #00d4ff, #0099cc)';
        title.style.color = '#000';
        title.innerHTML = `<strong>${this.selectedRegion.name}</strong> Transit Map`;
        regionList.appendChild(title);
        
        // Add line legend
        const legend = document.createElement('div');
        legend.className = 'subway-legend';
        legend.innerHTML = `
            <div style="padding: 10px; background: rgba(0,0,0,0.5); margin: 5px;">
                <div style="display: flex; align-items: center; margin: 5px 0;">
                    <div style="width: 30px; height: 4px; background: #00ff00; margin-right: 10px;"></div>
                    <span style="font-size: 11px;">High-Sec Line (0.5+)</span>
                </div>
                <div style="display: flex; align-items: center; margin: 5px 0;">
                    <div style="width: 30px; height: 4px; background: #ffff00; margin-right: 10px;"></div>
                    <span style="font-size: 11px;">Low-Sec Line (0.1-0.4)</span>
                </div>
                <div style="display: flex; align-items: center; margin: 5px 0;">
                    <div style="width: 30px; height: 4px; background: #ff4444; margin-right: 10px;"></div>
                    <span style="font-size: 11px;">Null-Sec Line (0.0-)</span>
                </div>
                <div style="display: flex; align-items: center; margin: 5px 0;">
                    <div style="width: 30px; height: 4px; background: #00d4ff; border: 1px dashed #fff; margin-right: 10px;"></div>
                    <span style="font-size: 11px;">Inter-Constellation</span>
                </div>
            </div>
        `;
        regionList.appendChild(legend);
        
        // List constellations as "lines"
        this.regionLayout.forEach((constLayout, constId) => {
            const constellation = this.getConstellationData(constId);
            if (!constellation) return;
            
            const item = document.createElement('div');
            item.className = 'constellation-item subway-style';
            
            // Count security types
            let highSec = 0, lowSec = 0, nullSec = 0;
            constLayout.systems.forEach(sys => {
                const sec = sys.system.security_status || 0;
                if (sec >= 0.5) highSec++;
                else if (sec >= 0.1) lowSec++;
                else nullSec++;
            });
            
            item.innerHTML = `
                <div class="constellation-name">${constellation.name} Line</div>
                <div class="constellation-stats">
                    <span>${constLayout.systems.size} stations</span>
                </div>
                <div class="security-breakdown" style="display: flex; gap: 5px; margin-top: 5px;">
                    ${highSec > 0 ? `<span style="color: #00ff00;">●${highSec}</span>` : ''}
                    ${lowSec > 0 ? `<span style="color: #ffff00;">●${lowSec}</span>` : ''}
                    ${nullSec > 0 ? `<span style="color: #ff4444;">●${nullSec}</span>` : ''}
                </div>
            `;
            
            item.onclick = () => this.focusOnConstellation(constId);
            regionList.appendChild(item);
        });
    }
}

// Update your main draw method
draw() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    if (this.viewMode === 'regions') {
        this.drawGrid();
        this.drawRegions();
    } else if (this.viewMode === 'region-detail') {
        this.drawGrid();
        this.drawRegionDetail();
    }
}
            
         // Replace this section in loadUniverseData method (around line 270-290)
async loadUniverseData() {
    try {
        document.getElementById('loadingProgress').textContent = 'Loading universe data...';
        
        // Try to load complete universe data first
        try {
            const response = await fetch('http://localhost:3001/api/universe/complete');
            if (response.ok) {
                this.universeData = await response.json();
                
                // Process regions with layout
                this.regions = [];
                for (const [regionId, regionData] of Object.entries(this.universeData.regions)) {
                    const layout = EVE_REGION_LAYOUT[regionData.name] || {
                        x: Math.random() * 10 - 5,
                        y: Math.random() * 10 - 5,
                        color: "#666666",
                        group: "unknown"
                    };
                    
                    this.regions.push({
                        id: parseInt(regionId),
                        name: regionData.name,
                        constellations: regionData.constellations,
                        position: {
                            x: layout.x * 300000000000000,  // ADD THIS
                            y: layout.y * 300000000000000,  // ADD THIS
                            z: 0
                        },
                        color: layout.color,
                        group: layout.group
                    });
                }
                
                document.getElementById('loadingProgress').textContent = 
                    `Loaded ${Object.keys(this.universeData.systems).length} systems in ${this.regions.length} regions`;
            }
        } catch (error) {
            console.log('No complete cache available, using optimized endpoint');
            
            // Fall back to optimized endpoint
            const overview = await this.api.getUniverseOverview();
            this.regions = overview.regions.map(region => {
                const layout = EVE_REGION_LAYOUT[region.name] || {
                    x: Math.random() * 10 - 5,
                    y: Math.random() * 10 - 5,
                    color: "#666666",
                    group: "unknown"
                };
                
                return {
                    ...region,
                    position: {
                        x: layout.x * 300000000000000,
                        y: layout.y * 300000000000000,
                        z: 0
                    },
                    color: layout.color,
                    group: layout.group
                };
            });
            
            document.getElementById('loadingProgress').textContent = 
                `Loaded ${this.regions.length} regions`;
        }
        
        // Load real-time data
        document.getElementById('loadingProgress').textContent = 'Loading real-time data...';
        await this.loadRealtimeData();
        
        this.populateRegionList();
        this.hideLoading();
        
        // Show regions view
        this.showRegionsView();
        
    } catch (error) {
        console.error('Error loading universe data:', error);
        document.getElementById('loadingProgress').textContent = 'Failed to load data';
        setTimeout(() => this.hideLoading(), 2000);
    }
}
            showRegionsView() {
                this.viewMode = 'regions';
                this.systems = [];
                this.selectedSystem = null;
                this.selectedRegion = null;
                document.getElementById('backToRegionsBtn').style.display = 'none';
                document.getElementById('selectedSystemName').textContent = 'None';
                document.getElementById('systemCount').textContent = '0';
                this.resetView();
                this.draw();
            }
            
 async selectRegion(region) {
    if (this.viewMode === 'regions') {
        // Switch to detailed view
        this.showRegionDetail(region);
        return; // Important: return here to prevent old behavior
    }
    
    // If already in detail view, just update selection
    this.selectedRegion = region;
    this.updateRegionDetailPanel();
    this.draw();
}

// Also, you need to add the helper methods that are missing:

showLoading(message) {
    document.getElementById('loadingOverlay').style.display = 'flex';
    document.getElementById('loadingProgress').textContent = message || 'Loading...';
}

async getRegionDetailData(regionId) {
    // Get region data from universe cache
    if (this.universeData) {
        const regionData = this.universeData.regions[regionId];
        if (!regionData) throw new Error('Region not found');
        
        // Build complete region data with constellations and systems
        const completeRegion = {
            ...regionData,
            constellations: []
        };
        
        // Get constellation details
        for (const constId of regionData.constellations) {
            const constellation = this.universeData.constellations[constId];
            if (constellation) {
                const constWithSystems = {
                    ...constellation,
                    systems: []
                };
                
                // Get systems for this constellation
                for (const systemId of constellation.systems) {
                    const system = this.universeData.systems[systemId];
                    if (system) {
                        constWithSystems.systems.push({
                            id: systemId,
                            name: system.name,
                            security_status: system.security_status,
                            position: system.position,
                            connections: system.stargates || []
                        });
                    }
                }
                
                completeRegion.constellations.push(constWithSystems);
            }
        }
        
        return completeRegion;
    } else {
        // Fallback to API
        const response = await fetch(`http://localhost:3001/api/universe/regions/${regionId}/details`);
        if (!response.ok) throw new Error('Failed to fetch region details');
        return await response.json();
    }
}

getConstellationData(constId) {
    if (this.universeData && this.universeData.constellations) {
        return this.universeData.constellations[constId];
    }
    return null;
}

getSystemData(systemId) {
    if (this.universeData && this.universeData.systems) {
        return this.universeData.systems[systemId];
    }
    return null;
}

focusOnConstellation(constId) {
    if (!this.regionLayout) return;
    
    const constLayout = this.regionLayout.get(constId);
    if (!constLayout) return;
    
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    
    const x = centerX + (constLayout.x - this.canvas.width * 0.4);
    const y = centerY + (constLayout.y - this.canvas.height * 0.4);
    
    this.scale = 2;
    this.offsetX = this.canvas.width / 2 - x * this.scale;
    this.offsetY = this.canvas.height / 2 - y * this.scale;
    
    this.selectedConstellation = constId;
    this.draw();
}
            
            loadCachedConnections() {
                this.connections = [];
                const systemIds = new Set(this.systems.map(s => s.system_id));
                
                // Get connections for loaded systems
                for (const connection of this.universeData.connections) {
                    if (systemIds.has(connection.from) && systemIds.has(connection.to)) {
                        const fromSystem = this.systems.find(s => s.system_id === connection.from);
                        const toSystem = this.systems.find(s => s.system_id === connection.to);
                        
                        if (fromSystem && toSystem) {
                            this.connections.push({
                                from: fromSystem,
                                to: toSystem,
                                type: 'stargate'
                            });
                        }
                    }
                }
                
                console.log(`Loaded ${this.connections.length} connections from cache`);
            }
            
            async loadSystemConnections() {
                this.connections = [];
                const maxConnections = 50;
                let loadedConnections = 0;
                
                for (const system of this.systems) {
                    if (loadedConnections >= maxConnections) break;
                    
                    if (system.stargates && system.stargates.length > 0) {
                        const stargateId = system.stargates[0];
                        
                        try {
                            const stargate = await this.api.getStargateInfo(stargateId);
                            const destinationSystemId = stargate.destination.system_id;
                            const destinationSystem = this.systems.find(s => s.system_id === destinationSystemId);
                            
                            if (destinationSystem) {
                                this.connections.push({
                                    from: system,
                                    to: destinationSystem,
                                    type: 'stargate'
                                });
                                loadedConnections++;
                            }
                            
                        } catch (error) {
                            // Skip failed stargate lookups
                        }
                    }
                    
                    if (loadedConnections % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
                
                console.log(`Loaded ${this.connections.length} system connections`);
            }
            
            async loadRealtimeData() {
                try {
                    const [kills, jumps] = await Promise.all([
                        this.api.getSystemKills(),
                        this.api.getSystemJumps()
                    ]);
                    
                    this.systemKills.clear();
                    if (kills && Array.isArray(kills)) {
                        kills.forEach(kill => {
                            this.systemKills.set(kill.system_id, kill);
                        });
                    }
                    
                    this.systemJumps.clear();
                    if (jumps && Array.isArray(jumps)) {
                        jumps.forEach(jump => {
                            this.systemJumps.set(jump.system_id, jump);
                        });
                    }
                    
                    console.log(`Loaded real-time data: ${this.systemKills.size} kill records, ${this.systemJumps.size} jump records`);
                    
                } catch (error) {
                    console.warn('Failed to load real-time data:', error);
                }
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (this.isDragging) {
                    const dx = e.clientX - this.lastX;
                    const dy = e.clientY - this.lastY;
                    
                    this.offsetX += dx;
                    this.offsetY += dy;
                    
                    this.lastX = e.clientX;
                    this.lastY = e.clientY;
                    
                    this.draw();
                } else {
                    // Check hover
                    const worldPos = this.screenToWorld(x, y);
                    
                    if (this.viewMode === 'regions') {
                        // Check region hover
                        let hoveredRegion = null;
                        
                        for (const region of this.regions) {
                            const regionX = region.position.x * 0.000000000001;
                            const regionY = region.position.y * 0.000000000001;
                            const distance = Math.sqrt(
                                Math.pow(worldPos.x - regionX, 2) + 
                                Math.pow(worldPos.y - regionY, 2)
                            );
                            
                            if (distance < 50 / this.scale) {
                                hoveredRegion = region;
                                break;
                            }
                        }
                        
                        if (hoveredRegion !== this.hoveredRegion) {
                            this.hoveredRegion = hoveredRegion;
                            this.canvas.style.cursor = hoveredRegion ? 'pointer' : 'grab';
                            this.draw();
                        }
                    } else {
                        // Original system hover logic
                        let hoveredSystem = null;
                        
                        for (const system of this.systems) {
                            if (!system.position) continue;
                            
                            const systemX = system.position.x * 0.000000000001;
                            const systemY = system.position.y * 0.000000000001;
                            const distance = Math.sqrt(
                                Math.pow(worldPos.x - systemX, 2) + 
                                Math.pow(worldPos.y - systemY, 2)
                            );
                            
                            if (distance < 10 / this.scale) {
                                hoveredSystem = system;
                                break;
                            }
                        }
                        
                        if (hoveredSystem !== this.hoveredSystem) {
                            this.hoveredSystem = hoveredSystem;
                            this.canvas.style.cursor = hoveredSystem ? 'pointer' : 'grab';
                            this.draw();
                        }
                    }
                }
            }
            
            draw() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Draw grid
    this.drawGrid();
    
    if (this.viewMode === 'regions') {
        // Draw regions overview
        this.drawRegions();
    } else if (this.viewMode === 'region-detail') {
        // Draw detailed region view
        this.drawRegionDetail();
    } else if (this.viewMode === 'systems') {
        // Draw old systems view
        if (this.showConnections) {
            this.drawConnections();
        }
        if (this.currentRoute.length > 0) {
            this.drawRoute();
        }
        this.drawSystems();
    }
}
            
            drawRegions() {
                const GRID_SIZE = 200;
                const rect = this.canvas.getBoundingClientRect();
                
                // Draw connections first
                this.ctx.strokeStyle = 'rgba(0, 212, 255, 0.1)';
                this.ctx.lineWidth = 2;
                
                if (typeof REGION_CONNECTIONS !== 'undefined') {
                    REGION_CONNECTIONS.forEach(([fromName, toName]) => {
                        const fromRegion = this.regions.find(r => r.name === fromName);
                        const toRegion = this.regions.find(r => r.name === toName);
                        
                        if (fromRegion && toRegion) {
                            const fromPos = this.worldToScreen(
                                fromRegion.position.x * 0.000000000001,
                                fromRegion.position.y * 0.000000000001
                            );
                            const toPos = this.worldToScreen(
                                toRegion.position.x * 0.000000000001,
                                toRegion.position.y * 0.000000000001
                            );
                            
                            this.ctx.beginPath();
                            this.ctx.moveTo(fromPos.x, fromPos.y);
                            this.ctx.lineTo(toPos.x, toPos.y);
                            this.ctx.stroke();
                        }
                    });
                }
                
                // Draw regions as hexagons
                this.regions.forEach(region => {
                    const screenPos = this.worldToScreen(
                        region.position.x * 0.000000000001,
                        region.position.y * 0.000000000001
                    );
                    
                    // Skip if outside viewport
                    if (screenPos.x < -100 || screenPos.x > rect.width + 100 || 
                        screenPos.y < -100 || screenPos.y > rect.height + 100) return;
                    
                    const isHovered = region === this.hoveredRegion;
                    const isSelected = region === this.selectedRegion;
                    
                    // Draw hexagon
                    const size = 45;
                    this.ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const x = screenPos.x + size * Math.cos(angle);
                        const y = screenPos.y + size * Math.sin(angle);
                        if (i === 0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    }
                    this.ctx.closePath();
                    
                    // Fill and stroke
                    this.ctx.fillStyle = isHovered ? '#0099cc' : 
                                        isSelected ? '#00d4ff' : 
                                        `${region.color || '#00d4ff'}33`;
                    this.ctx.strokeStyle = region.color || '#00d4ff';
                    this.ctx.lineWidth = 2;
                    
                    if (isHovered || isSelected) {
                        this.ctx.shadowColor = region.color || '#00d4ff';
                        this.ctx.shadowBlur = 20;
                    }
                    
                    this.ctx.fill();
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                    
                    // Draw region name
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 14px Consolas';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(region.name, screenPos.x, screenPos.y);
                    
                    // Draw system count
                    let systemCount = '?';
                    if (this.universeData && this.universeData.systems) {
                        systemCount = Object.values(this.universeData.systems)
                            .filter(s => s.region_id === region.id).length;
                    } else if (region.system_count) {
                        systemCount = region.system_count;
                    }
                    
                    this.ctx.font = '11px Consolas';
                    this.ctx.fillStyle = '#aaa';
                    this.ctx.fillText(`${systemCount} systems`, screenPos.x, screenPos.y + 15);
                });
            }
            
            // Keep all the other methods unchanged
            async searchSystemFromAPI(query) {
                try {
                    const response = await fetch(`http://localhost:3001/api/search/systems?query=${encodeURIComponent(query)}`);
                    const results = await response.json();
                    
                    if (results && results.length > 0) {
                        this.displaySearchResultsFromAPI(results);
                        
                        const loadedSystemIds = results
                            .map(r => r.id)
                            .filter(id => this.systems.some(s => s.system_id === id));
                        
                        this.highlightedSystems = this.systems.filter(s => 
                            loadedSystemIds.includes(s.system_id)
                        );
                        
                        this.draw();
                    } else {
                        this.hideSearchResults();
                    }
                } catch (error) {
                    console.error('Search failed:', error);
                    this.searchSystem(query);
                }
            }
            
            displaySearchResultsFromAPI(results) {
                const searchResultsPanel = document.getElementById('searchResultsPanel');
                const searchResults = document.getElementById('searchResults');
                
                searchResultsPanel.style.display = 'block';
                
                searchResults.innerHTML = results.map(system => {
                    const isLoaded = this.systems.some(s => s.system_id === system.id);
                    
                    return `
                        <div class="search-result" ${isLoaded ? `onclick='map.focusOnSystemById(${system.id})'` : ''}>
                            <div style="font-weight: bold; color: #00d4ff;">
                                ${system.name}
                                ${!isLoaded ? '<span style="color: #888; font-size: 10px;"> (not loaded)</span>' : ''}
                            </div>
                            <div style="font-size: 11px; color: #aaa;">
                                Security: ${system.security.toFixed(1)}
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            focusOnSystemById(systemId) {
                const system = this.systems.find(s => s.system_id === systemId);
                if (system) {
                    this.focusOnSystem(system);
                }
            }
            
            async planRoute(originSystemId, destinationSystemId) {
                if (!originSystemId || !destinationSystemId) {
                    console.warn('Cannot plan route: missing origin or destination');
                    return;
                }
                
                try {
                    document.getElementById('loadingProgress').textContent = 'Calculating route...';
                    document.getElementById('loadingOverlay').style.display = 'flex';
                    
                    const response = await fetch('http://localhost:3001/api/route/calculate', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            origin: originSystemId,
                            destination: destinationSystemId,
                            avoid: 'secure'
                        })
                    });
                    
                    const routeData = await response.json();
                    
                    this.currentRoute = [];
                    for (const systemId of routeData.route) {
                        const system = this.systems.find(s => s.system_id === systemId);
                        if (system) {
                            this.currentRoute.push(system);
                        }
                    }
                    
                    this.routeStart = this.systems.find(s => s.system_id === originSystemId);
                    this.routeEnd = this.systems.find(s => s.system_id === destinationSystemId);
                    
                    this.updateRouteDisplay();
                    this.switchTab('route');
                    this.draw();
                    
                    console.log(`Route calculated: ${routeData.jumps} jumps`);
                    
                } catch (error) {
                    console.error('Route planning failed:', error);
                    alert('Failed to calculate route. Please ensure the FastAPI backend is running.');
                } finally {
                    this.hideLoading();
                }
            }
            
            searchSystem(query) {
                if (!query || query.length < 2) {
                    this.highlightedSystems = [];
                    this.hideSearchResults();
                    this.draw();
                    return;
                }
                
                const matches = this.systems.filter(system => 
                    system.name.toLowerCase().includes(query.toLowerCase()) ||
                    (system.region_name && system.region_name.toLowerCase().includes(query.toLowerCase())) ||
                    (system.constellation_name && system.constellation_name.toLowerCase().includes(query.toLowerCase()))
                );
                
                this.highlightedSystems = matches.slice(0, 20);
                
                if (matches.length === 1) {
                    this.focusOnSystem(matches[0]);
                }
                
                this.draw();
                this.displaySearchResults(matches.slice(0, 10));
            }
            
            populateRegionList() {
                const regionList = document.getElementById('regionList');
                regionList.innerHTML = '';
                
                // Sort regions by group and name
                const sortedRegions = [...this.regions].sort((a, b) => {
                    if (a.group !== b.group) {
                        const groupOrder = { 'highsec': 0, 'lowsec': 1, 'nullsec': 2 };
                        return (groupOrder[a.group] || 3) - (groupOrder[b.group] || 3);
                    }
                    return a.name.localeCompare(b.name);
                });
                
                sortedRegions.forEach(region => {
                    const regionItem = document.createElement('div');
                    regionItem.className = 'region-item';
                    regionItem.innerHTML = `
                        <span style="color: ${region.color || '#00d4ff'}">●</span> ${region.name}
                    `;
                    regionItem.onclick = () => this.selectRegion(region);
                    regionList.appendChild(regionItem);
                });
            }
            
            focusOnSystems(systems) {
                if (systems.length === 0) return;
                
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                
                systems.forEach(system => {
                    const x = system.position.x * 0.000000000001;
                    const y = system.position.y * 0.000000000001;
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                });
                
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                const width = maxX - minX;
                const height = maxY - minY;
                
                const scaleX = this.canvas.width / (width * 1.5);
                const scaleY = this.canvas.height / (height * 1.5);
                this.scale = Math.min(scaleX, scaleY, 5);
                
                this.offsetX = this.canvas.width / 2 - centerX * this.scale;
                this.offsetY = this.canvas.height / 2 - centerY * this.scale;
                
                this.draw();
            }
            
            focusOnSystem(system) {
                if (!system || !system.position) return;
                
                const x = system.position.x * 0.000000000001;
                const y = system.position.y * 0.000000000001;
                
                this.scale = 3;
                this.offsetX = this.canvas.width / 2 - x * this.scale;
                this.offsetY = this.canvas.height / 2 - y * this.scale;
                
                this.selectedSystem = system;
                this.updateSystemInfo(system);
                this.draw();
            }
            
            worldToScreen(x, y) {
                return {
                    x: x * this.scale + this.offsetX,
                    y: y * this.scale + this.offsetY
                };
            }
            
            screenToWorld(x, y) {
                return {
                    x: (x - this.offsetX) / this.scale,
                    y: (y - this.offsetY) / this.scale
                };
            }
            
            handleMouseDown(e) {
                this.isDragging = true;
                this.lastX = e.clientX;
                this.lastY = e.clientY;
            }
            
            handleMouseUp() {
                this.isDragging = false;
            }
            
            handleWheel(e) {
                e.preventDefault();
                
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const worldPos = this.screenToWorld(mouseX, mouseY);
                
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                this.scale *= delta;
                this.scale = Math.max(0.1, Math.min(10, this.scale));
                
                this.offsetX = mouseX - worldPos.x * this.scale;
                this.offsetY = mouseY - worldPos.y * this.scale;
                
                document.getElementById('zoomLevel').textContent = Math.round(this.scale * 100) + '%';
                this.draw();
            }
            
            handleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const worldPos = this.screenToWorld(x, y);
                
                if (this.viewMode === 'regions') {
                    for (const region of this.regions) {
                        const regionX = region.position.x * 0.000000000001;
                        const regionY = region.position.y * 0.000000000001;
                        const distance = Math.sqrt(
                            Math.pow(worldPos.x - regionX, 2) + 
                            Math.pow(worldPos.y - regionY, 2)
                        );
                        
                        if (distance < 50 / this.scale) {
                            this.selectRegion(region);
                            break;
                        }
                    }
                } else {
                    for (const system of this.systems) {
                        if (!system.position) continue;
                        
                        const systemX = system.position.x * 0.000000000001;
                        const systemY = system.position.y * 0.000000000001;
                        const distance = Math.sqrt(
                            Math.pow(worldPos.x - systemX, 2) + 
                            Math.pow(worldPos.y - systemY, 2)
                        );
                        
                        if (distance < 10 / this.scale) {
                            this.selectSystem(system);
                            break;
                        }
                    }
                }
            }
            
            selectSystem(system) {
                this.selectedSystem = system;
                this.updateSystemInfo(system);
                document.getElementById('selectedSystemName').textContent = system.name;
                this.draw();
            }
            
            updateSystemInfo(system) {
                const systemInfo = document.getElementById('systemInfo');
                if (!system) {
                    systemInfo.innerHTML = `
                        <div style="text-align: center; color: #666; padding: 20px;">
                            Click on a system to view details
                        </div>
                    `;
                    return;
                }
                
                const security = system.security_status ? system.security_status.toFixed(1) : 'Unknown';
                const securityColor = this.getSecurityColor(system.security_status || 0);
                
                systemInfo.innerHTML = `
                    <div class="system-info">
                        <div class="system-name">${system.name}</div>
                        
                        <div class="stat-item">
                            <span class="stat-label">Security Status:</span>
                            <span class="stat-value" style="color: ${securityColor};">${security}</span>
                        </div>
                        
                        <div class="stat-item">
                            <span class="stat-label">Region:</span>
                            <span class="stat-value">${system.region_name || 'Unknown'}</span>
                        </div>
                        
                        <div class="stat-item">
                            <span class="stat-label">Constellation:</span>
                            <span class="stat-value">${system.constellation_name || 'Unknown'}</span>
                        </div>
                        
                        <div class="stat-item">
                            <span class="stat-label">System ID:</span>
                            <span class="stat-value">${system.system_id || 'Unknown'}</span>
                        </div>
                        
                        <div style="margin-top: 15px;">
                            <button class="btn" onclick="map.setRouteStart(${system.system_id})">Set as Origin</button>
                            <button class="btn" onclick="map.setRouteEnd(${system.system_id})" style="margin-top: 5px;">Set as Destination</button>
                        </div>
                    </div>
                `;
                
                this.updateSystemStats(system);
            }
            
            updateSystemStats(system) {
                if (!system) return;
                
                const kills = this.systemKills.get(system.system_id) || { ship_kills: 0, pod_kills: 0, npc_kills: 0 };
                const jumps = this.systemJumps.get(system.system_id) || { ship_jumps: 0 };
                
                document.getElementById('shipKills').textContent = kills.ship_kills || 0;
                document.getElementById('podKills').textContent = kills.pod_kills || 0;
                document.getElementById('systemJumps').textContent = jumps.ship_jumps || 0;
                
                const killsWeight = (kills.ship_kills || 0) * 2;
                const jumpsWeight = (jumps.ship_jumps || 0) * 0.1;
                const activityScore = Math.min((killsWeight + jumpsWeight) / 50, 1);
                
                document.getElementById('activityFill').style.width = (activityScore * 100) + '%';
            }
            
            getSecurityColor(security) {
                if (security >= 0.5) return '#00ff00';
                if (security >= 0.1) return '#ffff00';
                if (security >= 0.0) return '#ff8800';
                return '#ff4444';
            }
            
            drawGrid() {
                this.ctx.strokeStyle = 'rgba(0, 212, 255, 0.05)';
                this.ctx.lineWidth = 1;
                
                const gridSize = 100 * this.scale;
                const startX = Math.floor(-this.offsetX / gridSize) * gridSize + this.offsetX;
                const startY = Math.floor(-this.offsetY / gridSize) * gridSize + this.offsetY;
                
                for (let x = startX; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = startY; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }
            
            drawConnections() {
                this.ctx.strokeStyle = 'rgba(0, 212, 255, 0.2)';
                this.ctx.lineWidth = 1;
                
                this.connections.forEach(connection => {
                    if (!connection.from.position || !connection.to.position) return;
                    
                    const from = this.worldToScreen(
                        connection.from.position.x * 0.000000000001,
                        connection.from.position.y * 0.000000000001
                    );
                    const to = this.worldToScreen(
                        connection.to.position.x * 0.000000000001,
                        connection.to.position.y * 0.000000000001
                    );
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(from.x, from.y);
                    this.ctx.lineTo(to.x, to.y);
                    this.ctx.stroke();
                });
            }
            
            drawRoute() {
                this.ctx.strokeStyle = '#00d4ff';
                this.ctx.lineWidth = 3;
                this.ctx.shadowColor = '#00d4ff';
                this.ctx.shadowBlur = 10;
                
                for (let i = 0; i < this.currentRoute.length - 1; i++) {
                    const from = this.worldToScreen(
                        this.currentRoute[i].position.x * 0.000000000001,
                        this.currentRoute[i].position.y * 0.000000000001
                    );
                    const to = this.worldToScreen(
                        this.currentRoute[i + 1].position.x * 0.000000000001,
                        this.currentRoute[i + 1].position.y * 0.000000000001
                    );
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(from.x, from.y);
                    this.ctx.lineTo(to.x, to.y);
                    this.ctx.stroke();
                }
                
                this.ctx.shadowBlur = 0;
            }
            
            drawSystems() {
                const rect = this.canvas.getBoundingClientRect();
                
                this.systems.forEach(system => {
                    if (!system.position) return;
                    
                    const screenPos = this.worldToScreen(
                        system.position.x * 0.000000000001,
                        system.position.y * 0.000000000001
                    );
                    
                    if (screenPos.x < -50 || screenPos.x > rect.width + 50 || 
                        screenPos.y < -50 || screenPos.y > rect.height + 50) return;
                    
                    const isHighlighted = this.highlightedSystems.includes(system);
                    const isInRoute = this.currentRoute.includes(system);
                    const isSelected = system === this.selectedSystem;
                    const isHovered = system === this.hoveredSystem;
                    const isRouteEndpoint = system === this.routeStart || system === this.routeEnd;
                    
                    let color = this.getSecurityColor(system.security_status || 0);
                    let radius = 3;
                    
                    if (isSelected) {
                        radius = 8;
                    } else if (isHovered) {
                        radius = 6;
                    } else if (isRouteEndpoint) {
                        radius = 7;
                        color = '#ff00ff';
                    } else if (isInRoute) {
                        radius = 5;
                        color = '#00d4ff';
                    } else if (isHighlighted) {
                        radius = 4;
                    }
                    
                    if (isSelected || isHovered || isInRoute || isRouteEndpoint) {
                        this.ctx.shadowColor = color;
                        this.ctx.shadowBlur = isSelected ? 20 : 15;
                    }
                    
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.shadowBlur = 0;
                    
                    const shouldShowLabel = 
                        this.showLabels === 'always' ||
                        (this.showLabels === 'auto' && this.scale > 1.5) ||
                        isSelected || isHovered || isInRoute || isRouteEndpoint;
                    
                    if (shouldShowLabel) {
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.font = `${Math.min(12, 8 + this.scale)}px Consolas`;
                        this.ctx.textAlign = 'center';
                        this.ctx.strokeStyle = '#000000';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeText(system.name, screenPos.x, screenPos.y - radius - 5);
                        this.ctx.fillText(system.name, screenPos.x, screenPos.y - radius - 5);
                    }
                });
            }
            
            planRouteFromInputs() {
                const fromInput = document.getElementById('routeFrom').value.trim();
                const toInput = document.getElementById('routeTo').value.trim();
                
                if (!fromInput || !toInput) {
                    alert('Please enter both origin and destination systems');
                    return;
                }
                
                const fromSystem = this.systems.find(s => 
                    s.name.toLowerCase() === fromInput.toLowerCase()
                );
                const toSystem = this.systems.find(s => 
                    s.name.toLowerCase() === toInput.toLowerCase()
                );
                
                if (!fromSystem) {
                    alert(`Origin system "${fromInput}" not found`);
                    return;
                }
                
                if (!toSystem) {
                    alert(`Destination system "${toInput}" not found`);
                    return;
                }
                
                this.planRoute(fromSystem.system_id, toSystem.system_id);
            }
            
            updateRouteDisplay() {
                const routeSteps = document.getElementById('routeSteps');
                const totalJumps = document.getElementById('totalJumps');
                
                totalJumps.textContent = Math.max(0, this.currentRoute.length - 1);
                
                routeSteps.innerHTML = '';
                
                if (this.currentRoute.length === 0) {
                    routeSteps.innerHTML = '<div class="route-step"><span>No route calculated</span></div>';
                    return;
                }
                
                this.currentRoute.forEach((system, index) => {
                    const step = document.createElement('div');
                    step.className = 'route-step';
                    
                    const security = system.security_status ? system.security_status.toFixed(1) : '?';
                    const securityColor = this.getSecurityColor(system.security_status || 0);
                    
                    step.innerHTML = `
                        <span>${index + 1}. ${system.name}</span>
                        <span style="color: ${securityColor}; font-weight: bold;">${security}</span>
                    `;
                    
                    step.addEventListener('click', () => this.focusOnSystem(system));
                    routeSteps.appendChild(step);
                });
            }
            
            displaySearchResults(results) {
                const searchResultsPanel = document.getElementById('searchResultsPanel');
                const searchResults = document.getElementById('searchResults');
                
                if (results.length === 0) {
                    searchResultsPanel.style.display = 'none';
                    return;
                }
                
                searchResultsPanel.style.display = 'block';
                
                searchResults.innerHTML = results.map(system => {
                    const systemStr = JSON.stringify({
                        name: system.name,
                        system_id: system.system_id,
                        position: system.position
                    }).replace(/"/g, '&quot;');
                    
                    return `
                        <div class="search-result" onclick='map.focusOnSystem(${systemStr})'>
                            <div style="font-weight: bold; color: #00d4ff;">${system.name}</div>
                            <div style="font-size: 11px; color: #aaa;">
                                ${system.region_name || 'Unknown Region'} 
                                (${system.security_status ? system.security_status.toFixed(1) : '?'})
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            hideSearchResults() {
                const searchResultsPanel = document.getElementById('searchResultsPanel');
                if (searchResultsPanel) {
                    searchResultsPanel.style.display = 'none';
                }
            }
            
            setRouteStart(systemId) {
                const system = this.systems.find(s => s.system_id === systemId);
                if (system) {
                    document.getElementById('routeFrom').value = system.name;
                    this.routeStart = system;
                    this.switchTab('route');
                }
            }
            
            setRouteEnd(systemId) {
                const system = this.systems.find(s => s.system_id === systemId);
                if (system) {
                    document.getElementById('routeTo').value = system.name;
                    this.routeEnd = system;
                    this.switchTab('route');
                }
            }
            
            clearRoute() {
                this.currentRoute = [];
                this.routeStart = null;
                this.routeEnd = null;
                document.getElementById('routeFrom').value = '';
                document.getElementById('routeTo').value = '';
                this.updateRouteDisplay();
                this.draw();
            }
            
            switchTab(tab) {
                document.querySelectorAll('.filter-tab').forEach(t => {
                    t.classList.toggle('active', t.dataset.filter === tab);
                });
                
                document.getElementById('regionsPanel').style.display = tab === 'regions' ? 'block' : 'none';
                document.getElementById('routePanel').style.display = tab === 'route' ? 'block' : 'none';
            }
            
            resetView() {
                this.scale = 1;
                this.offsetX = this.canvas.width / 2;
                this.offsetY = this.canvas.height / 2;
                document.getElementById('zoomLevel').textContent = '100%';
                this.draw();
            }
            
            hideLoading() {
                document.getElementById('loadingOverlay').style.display = 'none';
            }
            
            zoomIn() {
                this.scale *= 1.2;
                this.scale = Math.min(this.scale, 10);
                document.getElementById('zoomLevel').textContent = Math.round(this.scale * 100) + '%';
                this.draw();
            }
            
            zoomOut() {
                this.scale *= 0.8;
                this.scale = Math.max(this.scale, 0.1);
                document.getElementById('zoomLevel').textContent = Math.round(this.scale * 100) + '%';
                this.draw();
            }
            
            toggleConnections() {
                this.showConnections = !this.showConnections;
                document.getElementById('showConnections').textContent = this.showConnections ? 'Yes' : 'No';
                this.draw();
            }
            
            toggleLabels() {
                const modes = ['auto', 'always', 'never'];
                const currentIndex = modes.indexOf(this.showLabels);
                this.showLabels = modes[(currentIndex + 1) % modes.length];
                
                const labels = {
                    'auto': 'Auto',
                    'always': 'Always',
                    'never': 'Never'
                };
                
                document.getElementById('showLabels').textContent = labels[this.showLabels];
                this.draw();
            }
        }

        // Initialize the map
        let map;
        window.map = null;

        document.addEventListener('DOMContentLoaded', () => {
            map = new EVEUniverseMap2D();
            window.map = map;
            console.log('EVE Universe Map initialized with FastAPI backend');
        });
    </script>
</body>
</html>