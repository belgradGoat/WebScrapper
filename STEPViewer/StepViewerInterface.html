<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STEP File Viewer</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .upload-section {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            background: rgba(102, 126, 234, 0.05);
        }

        .upload-section:hover {
            border-color: #764ba2;
            background: rgba(118, 75, 162, 0.05);
            transform: translateY(-2px);
        }

        .upload-section.dragover {
            border-color: #52c41a;
            background: rgba(82, 196, 26, 0.1);
        }

        input[type="file"] {
            display: none;
        }

        .upload-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .control-btn {
            background: white;
            border: 2px solid #667eea;
            color: #667eea;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-1px);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .viewer-container {
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        #canvas {
            width: 100%;
            height: 500px;
            background: #f8f9fa;
            display: block;
        }

        .info-panel {
            background: rgba(102, 126, 234, 0.05);
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .info-item {
            margin-bottom: 10px;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            border-left: 4px solid #667eea;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .success {
            color: #52c41a;
            font-weight: 600;
        }

        .error {
            color: #ff4d4f;
            font-weight: 600;
        }

        .download-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .download-btn {
            background: linear-gradient(45deg, #52c41a, #73d13d);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .download-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(82, 196, 26, 0.3);
        }

        .download-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .message {
            padding: 10px 15px;
            border-radius: 6px;
            margin: 10px 0;
            text-align: center;
            font-weight: 600;
        }

        .message.success {
            background: rgba(82, 196, 26, 0.1);
            border: 1px solid #52c41a;
            color: #52c41a;
        }

        .message.error {
            background: rgba(255, 77, 79, 0.1);
            border: 1px solid #ff4d4f;
            color: #ff4d4f;
        }

        .message.info {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid #667eea;
            color: #667eea;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîß STEP File Viewer</h1>
        
        <div class="upload-section" id="uploadSection">
            <p style="font-size: 18px; margin-bottom: 15px;">Drop your STEP file here or click to browse</p>
            <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                üìÅ Choose STEP File
            </button>
            <input type="file" id="fileInput" accept=".step,.stp" onchange="handleFileSelect(event)">
            <p style="font-size: 14px; color: #666; margin-top: 15px;">Supported formats: .step, .stp</p>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Processing STEP file...</p>
        </div>

        <div id="messages"></div>

        <div class="controls">
            <button class="control-btn" id="loadBtn" onclick="loadFile()" disabled>üìÇ Load File</button>
            <button class="control-btn" id="createUCSBtn" onclick="createUCS()" disabled>üìê Create UCS</button>
            <button class="control-btn" id="screenshotBtn" onclick="takeScreenshot()" disabled>üì∏ Take Screenshot</button>
            <button class="control-btn" id="saveBtn" onclick="saveSTEPCopy()" disabled>üíæ Save Copy</button>
            <button class="control-btn" id="measureBtn" onclick="toggleMeasurement()" disabled>üìè Measure</button>
            <button class="control-btn" id="wireframeBtn" onclick="toggleWireframe()" disabled>üî≤ Wireframe</button>
            <button class="control-btn" onclick="resetView()" disabled>üîÑ Reset View</button>
            <button class="control-btn" onclick="exportToGLTF()" id="exportGLTFBtn" disabled>üéØ Export to glTF</button>
            <button class="control-btn" onclick="exportTransformedSTEP()" id="exportTransformedBtn" disabled>üì§ Export Transformed STEP</button>
        </div>

        <div class="viewer-container">
            <canvas id="canvas" style="display: none;"></canvas>
            <div id="svgViewer" style="width: 100%; height: 500px; background: #f8f9fa; display: flex; align-items: center; justify-content: center;">
                <p style="color: #999;">Load a STEP file to see visualization</p>
            </div>
        </div>

        <div class="info-panel" id="infoPanel" style="display: none;">
            <h3>File Information</h3>
            <div id="fileInfo"></div>
            
            <h3>UCS Information</h3>
            <div id="ucsInfo"></div>
        </div>

        <div class="download-section">
            <button class="download-btn" id="downloadImageBtn" onclick="downloadImage()" disabled>
                üñºÔ∏è Download Screenshot
            </button>
            <button class="download-btn" id="downloadSTEPBtn" onclick="downloadSTEP()" disabled>
                üìÑ Download STEP Copy
            </button>
        </div>
    </div>

    <!-- Load Three.js modules first -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
    </script>
    
    <!-- Load the compiled WASM module -->
    <script src="step_viewer.js"></script>
    
    <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { TransformControls } from 'three/addons/controls/TransformControls.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Make available globally
    window.THREE = THREE;
    window.GLTFLoader = GLTFLoader;
    window.TransformControls = TransformControls;
    window.OrbitControls = OrbitControls;

    // Signal that Three.js is ready
    window.dispatchEvent(new Event('threejs-ready'));
    </script>
    
    <script>
    // Global variables
    let Module = null;
    let currentFile = null;
    let screenshotData = null;
    let stepCopyData = null;
    let isModuleReady = false;

    let scene, camera, renderer, controls;
    let meshObject = null;
    let measurementMode = false;
    let measurementPoints = [];
    let measurementLines = [];
    let measurementMarkers = [];

    // Wait for Three.js modules to load
    window.addEventListener('threejs-ready', () => {
        window.THREE = window.THREE;
        window.GLTFLoader = window.GLTFLoader;
        window.TransformControls = window.TransformControls;
        window.OrbitControls = window.OrbitControls;
        
        // Now initialize your app
        initializeApp();
    });

    window.addEventListener('resize', () => {
        if (camera && renderer) {
            const container = document.getElementById('svgViewer');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
    });

    // Initialize app
    async function initializeApp() {
        try {
            showMessage('Initializing STEP Viewer...', 'info');
            console.log('Starting initialization...');
            
            // Initialize your WASM module
            if (typeof createModule !== 'undefined') {
                console.log('Loading WASM module...');
                Module = await createModule({
                    onRuntimeInitialized: function() {
                        console.log('WASM runtime initialized');
                        isModuleReady = true;
                        
                        // Initialize the C++ processor
                        try {
                            if (Module._initApp) {
                                Module._initApp();
                                console.log('C++ processor initialized via direct call');
                            } else {
                                console.error('_initApp function not found');
                            }
                        } catch (e) {
                            console.error('Failed to initialize C++ processor:', e);
                        }
                    },
                    print: (text) => console.log('Module output:', text),
                    printErr: (text) => console.error('Module error:', text)
                });
            } else {
                console.log('createModule not found, running in demo mode');
                isModuleReady = false;
                showMessage('Running in demo mode - limited functionality', 'info');
            }
            
            // Set up drag and drop listeners
            setupDragAndDrop();
            
            showMessage('STEP Viewer ready!', 'success');
            
        } catch (error) {
            console.error('Failed to initialize app:', error);
            showMessage('Failed to initialize application: ' + error.message, 'error');
            isModuleReady = false;
            setupDragAndDrop();
        }
    }

    // Initialize Three.js scene
    function initThreeJS() {
        const container = document.getElementById('svgViewer');
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // Scene setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf8f9fa);
        
        // Camera setup
        camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 10000);
        camera.position.set(100, 100, 200);
        
        // Renderer setup
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.innerHTML = '';
        container.appendChild(renderer.domElement);
        
        // Setup controls
        setupOrbitControls();
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(100, 100, 50);
        scene.add(directionalLight);
        
        // Grid helper
        const gridHelper = new THREE.GridHelper(200, 20);
        scene.add(gridHelper);
        
        // Axes helper
        const axesHelper = new THREE.AxesHelper(50);
        scene.add(axesHelper);
        
        // Add click handler for measurements
        renderer.domElement.addEventListener('click', addMeasurementPoint);
        
        animate();
    }
    
    // Setup orbit controls
    function setupOrbitControls() {
        if (!OrbitControls) {
            console.error('OrbitControls not loaded');
            return;
        }
        
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 10;
        controls.maxDistance = 1000;
        controls.maxPolarAngle = Math.PI;
        controls.target.set(0, 0, 0);
    }

    function animate() {
        requestAnimationFrame(animate);
        if (controls && controls.update) {
            controls.update();
        }
        if (renderer && scene && camera) {
            renderer.render(scene, camera);
        }
    }

    // Transformation tracking
    class TransformationManager {
        constructor() {
            this.transformations = [];
            this.originalMatrix = new THREE.Matrix4();
        }
        
        startTracking(object) {
            this.originalMatrix.copy(object.matrixWorld);
        }
        
        addTransformation(type, data) {
            this.transformations.push({
                type: type,
                timestamp: Date.now(),
                data: data
            });
        }
        
        trackRotation(euler) {
            this.addTransformation('rotation', {
                x: euler.x,
                y: euler.y,
                z: euler.z
            });
        }
        
        trackTranslation(position) {
            this.addTransformation('translation', {
                x: position.x,
                y: position.y,
                z: position.z
            });
        }
        
        trackScale(scale) {
            this.addTransformation('scale', {
                x: scale.x,
                y: scale.y,
                z: scale.z
            });
        }
        
        getTransformationMatrix() {
            const matrix = new THREE.Matrix4();
            
            for (const transform of this.transformations) {
                switch (transform.type) {
                    case 'translation':
                        matrix.makeTranslation(
                            transform.data.x,
                            transform.data.y,
                            transform.data.z
                        );
                        break;
                    case 'rotation':
                        const rotMatrix = new THREE.Matrix4();
                        rotMatrix.makeRotationFromEuler(
                            new THREE.Euler(
                                transform.data.x,
                                transform.data.y,
                                transform.data.z
                            )
                        );
                        matrix.multiply(rotMatrix);
                        break;
                    case 'scale':
                        matrix.scale(new THREE.Vector3(
                            transform.data.x,
                            transform.data.y,
                            transform.data.z
                        ));
                        break;
                }
            }
            
            return matrix;
        }
        
        exportToJSON() {
            return JSON.stringify(this.transformations);
        }
    }

    const transformManager = new TransformationManager();

    // Main file loading function
    async function loadFile() {
        if (!currentFile) {
            showMessage('No file selected', 'error');
            return;
        }

        showLoading(true);
        
        try {
            // Read file
            const arrayBuffer = await readFileAsArrayBuffer(currentFile);
            console.log('File read successfully, size:', arrayBuffer.byteLength);
            
            // Initialize Three.js if needed
            if (!renderer) {
                console.log('Initializing Three.js...');
                initThreeJS();
            }
            
            // Step 1: Convert STEP to glTF using C++ module
            let gltfData = null;
            
            if (Module && isModuleReady) {
                try {
                    // Write STEP file to WASM filesystem
                    const filename = '/tmp/' + currentFile.name;
                    const uint8Array = new Uint8Array(arrayBuffer);
                    Module.FS.writeFile(filename, uint8Array);
                    
                    // Load STEP file in C++ module
                    const loadResult = Module.ccall('loadSTEPFile', 'number', ['string'], [filename]);
                    
                    if (loadResult === 1) {
                        // Convert to glTF
                        const gltfFilename = '/tmp/converted.gltf';
                        const exportResult = Module.ccall('exportToGLTF', 'number', ['string'], [gltfFilename]);
                        
                        if (exportResult === 1) {
                            // Read glTF data
                            gltfData = Module.FS.readFile(gltfFilename, { encoding: 'utf8' });
                            console.log('STEP converted to glTF successfully');
                        }
                    }
                } catch (error) {
                    console.error('STEP to glTF conversion error:', error);
                }
            }
            
            // Step 2: Load glTF into Three.js
            if (gltfData) {
                await loadGLTFIntoThreeJS(gltfData);
                enableInteractionControls();
                showFileInfo();
                showMessage('STEP file converted and loaded successfully!', 'success');
            } else {
                // Fallback - load mesh data directly from C++ module
                loadMeshIntoThreeJS();
                showFileInfo();
            }
            
        } catch (error) {
            console.error('Error loading file:', error);
            showMessage('Failed to load STEP file: ' + error.message, 'error');
            // Load demo mesh
            createDemoMesh();
        } finally {
            showLoading(false);
        }
    }

    // Load glTF into Three.js
    async function loadGLTFIntoThreeJS(gltfData) {
        const loader = new GLTFLoader();
        
        // Convert string to blob
        const blob = new Blob([gltfData], { type: 'model/gltf+json' });
        const url = URL.createObjectURL(blob);
        
        return new Promise((resolve, reject) => {
            loader.load(
                url,
                (gltf) => {
                    // Remove existing mesh
                    if (meshObject) {
                        scene.remove(meshObject);
                        meshObject.traverse((child) => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        });
                    }
                    
                    // Add glTF scene
                    meshObject = gltf.scene;
                    scene.add(meshObject);
                    
                    // Center camera
                    const box = new THREE.Box3().setFromObject(meshObject);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    
                    camera.position.set(
                        center.x + maxDim * 1.5,
                        center.y + maxDim * 1.5,
                        center.z + maxDim * 1.5
                    );
                    camera.lookAt(center);
                    
                    if (controls) {
                        controls.target.copy(center);
                    }
                    
                    URL.revokeObjectURL(url);
                    resolve();
                },
                (progress) => {
                    console.log('Loading glTF...', progress);
                },
                (error) => {
                    URL.revokeObjectURL(url);
                    reject(error);
                }
            );
        });
    }

    // Load mesh data directly from C++ module
    function loadMeshIntoThreeJS() {
        if (!Module || !isModuleReady) {
            console.error('Module not ready');
            return;
        }
        
        const vertexCount = Module._getVertexCount();
        const indexCount = Module._getIndexCount();
        const normalCount = Module._getNormalCount();
        
        console.log(`Loading mesh: ${vertexCount} vertices, ${indexCount} indices, ${normalCount} normals`);
        
        if (vertexCount === 0) {
            showMessage('No mesh data available', 'error');
            return;
        }
        
        // Remove existing mesh
        if (meshObject) {
            scene.remove(meshObject);
            meshObject.geometry.dispose();
            meshObject.material.dispose();
        }
        
        // Get mesh data pointers
        const vertexPtr = Module._getVertices();
        const indexPtr = Module._getIndices();
        const normalPtr = Module._getNormals();
        
        // Create typed arrays
        const vertices = new Float32Array(Module.HEAPF32.buffer, vertexPtr, vertexCount);
        const indices = new Uint32Array(Module.HEAPU32.buffer, indexPtr, indexCount);
        const normals = normalCount > 0 ? new Float32Array(Module.HEAPF32.buffer, normalPtr, normalCount) : null;
        
        // Create geometry
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        
        if (normals && normalCount > 0) {
            geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
        } else {
            geometry.computeVertexNormals();
        }
        
        geometry.setIndex(new THREE.BufferAttribute(indices, 1));
        
        // Create material
        const material = new THREE.MeshPhongMaterial({
            color: 0x667eea,
            specular: 0x111111,
            shininess: 100,
            side: THREE.DoubleSide,
            wireframe: false
        });
        
        // Create mesh
        meshObject = new THREE.Mesh(geometry, material);
        scene.add(meshObject);
        
        // Center camera
        geometry.computeBoundingBox();
        const box = geometry.boundingBox;
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        
        // Position camera
        camera.position.set(
            center.x + maxDim * 1.5,
            center.y + maxDim * 1.5,
            center.z + maxDim * 1.5
        );
        camera.lookAt(center);
        
        if (controls) {
            controls.target.copy(center);
        }
        
        enableViewerButtons();
        showMessage(`3D model loaded successfully!`, 'success');
    }

    // Enable interaction controls
    function enableInteractionControls() {
        if (!meshObject || !TransformControls) return;
        
        // Start tracking transformations
        transformManager.startTracking(meshObject);
        
        // Add transform controls
        const transformControls = new TransformControls(camera, renderer.domElement);
        transformControls.attach(meshObject);
        scene.add(transformControls);
        
        // Disable orbit controls when using transform controls
        transformControls.addEventListener('dragging-changed', (event) => {
            if (controls) controls.enabled = !event.value;
        });
        
        // Track changes
        transformControls.addEventListener('change', () => {
            if (transformControls.mode === 'translate') {
                transformManager.trackTranslation(meshObject.position);
            } else if (transformControls.mode === 'rotate') {
                transformManager.trackRotation(meshObject.rotation);
            } else if (transformControls.mode === 'scale') {
                transformManager.trackScale(meshObject.scale);
            }
        });
        
        // Add keyboard controls
        window.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'g': // Translate
                    transformControls.setMode('translate');
                    break;
                case 'r': // Rotate
                    transformControls.setMode('rotate');
                    break;
                case 's': // Scale
                    transformControls.setMode('scale');
                    break;
            }
        });
        
        enableViewerButtons();
    }

    // Export with transformations
    async function exportTransformedSTEP() {
        if (!Module || !isModuleReady || !currentFile) {
            showMessage('No file loaded', 'error');
            return;
        }
        
        showLoading(true);
        
        try {
            // Get transformation data
            const transformJSON = transformManager.exportToJSON();
            
            // For now, save with transformation info in header
            const filename = '/tmp/transformed.step';
            const result = Module.ccall('saveSTEPCopy', 'number', ['string'], [filename]);
            
            if (result === 1) {
                // Read the file
                const stepData = Module.FS.readFile(filename, { encoding: 'utf8' });
                
                // Add transformation info
                const transformedData = `/* Transformations Applied:\n${transformJSON}\n*/\n${stepData}`;
                
                // Download
                const blob = new Blob([transformedData], { type: 'application/step' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = currentFile.name.replace(/\.(step|stp)$/i, '_transformed.step');
                a.click();
                URL.revokeObjectURL(url);
                
                showMessage('Transformed STEP file exported successfully!', 'success');
            } else {
                showMessage('Failed to export transformed STEP', 'error');
            }
            
        } catch (error) {
            console.error('Export error:', error);
            showMessage('Failed to export: ' + error.message, 'error');
        } finally {
            showLoading(false);
        }
    }

    // Create demo mesh
    function createDemoMesh() {
        if (!renderer) {
            initThreeJS();
        }
        
        // Remove existing mesh
        if (meshObject) {
            scene.remove(meshObject);
            meshObject.geometry.dispose();
            meshObject.material.dispose();
        }
        
        // Create demo box
        const geometry = new THREE.BoxGeometry(50, 50, 50);
        const material = new THREE.MeshPhongMaterial({
            color: 0x667eea,
            specular: 0x111111,
            shininess: 100,
            side: THREE.DoubleSide
        });
        
        meshObject = new THREE.Mesh(geometry, material);
        scene.add(meshObject);
        
        // Center camera
        camera.position.set(100, 100, 100);
        camera.lookAt(0, 0, 0);
        if (controls) {
            controls.target.set(0, 0, 0);
        }
        
        enableViewerButtons();
        showMessage('Demo 3D model loaded!', 'info');
    }

    // UI functions
    async function createUCS() {
        if (!isModuleReady) {
            showMessage('Module not ready', 'error');
            return;
        }

        showLoading(true);
        
        try {
            if (Module && Module.ccall) {
                Module.ccall('createUCS', null, [], []);
                
                // Get UCS info and track it
                const ucsInfo = Module.ccall('getUCSInfo', 'string', [], []);
                transformManager.addTransformation('ucs', { info: ucsInfo });
            }
            
            showUCSInfo();
            showMessage('UCS created!', 'success');
            
        } catch (error) {
            console.error('Error creating UCS:', error);
            showMessage('Failed to create UCS: ' + error.message, 'error');
        } finally {
            showLoading(false);
        }
    }

    async function takeScreenshot() {
        if (!renderer) {
            showMessage('No 3D view to capture', 'error');
            return;
        }

        try {
            // Render the scene
            renderer.render(scene, camera);
            
            // Get canvas data
            const dataURL = renderer.domElement.toDataURL('image/png');
            screenshotData = dataURL;
            
            // Enable download button
            document.getElementById('downloadImageBtn').disabled = false;
            
            showMessage('Screenshot captured!', 'success');
        } catch (error) {
            console.error('Error taking screenshot:', error);
            showMessage('Failed to take screenshot', 'error');
        }
    }

    async function saveSTEPCopy() {
        if (!isModuleReady) {
            showMessage('Module not ready', 'error');
            return;
        }

        showLoading(true);
        
        try {
            const filename = '/tmp/copy.step';
            
            if (Module && Module.ccall && Module.FS) {
                const result = Module.ccall('saveSTEPCopy', 'number', ['string'], [filename]);
                
                if (result === 1) {
                    try {
                        const stepData = Module.FS.readFile(filename, { encoding: 'utf8' });
                        stepCopyData = new Blob([stepData], { type: 'application/step' });
                        document.getElementById('downloadSTEPBtn').disabled = false;
                        showMessage('STEP copy saved!', 'success');
                    } catch (e) {
                        console.error('Error reading STEP file:', e);
                        showMessage('Failed to save STEP copy', 'error');
                    }
                }
            }
        } catch (error) {
            console.error('Error saving STEP copy:', error);
            showMessage('Failed to save STEP copy: ' + error.message, 'error');
        } finally {
            showLoading(false);
        }
    }

    async function exportToGLTF() {
        if (!isModuleReady || !currentFile) {
            showMessage('Please load a STEP file first', 'error');
            return;
        }
        
        showLoading(true);
        
        try {
            const filename = '/tmp/model.gltf';
            
            if (Module && Module.ccall) {
                const result = Module.ccall('exportToGLTF', 'number', ['string'], [filename]);
                
                if (result === 1) {
                    try {
                        const gltfData = Module.FS.readFile(filename, { encoding: 'utf8' });
                        
                        // Create download
                        const blob = new Blob([gltfData], { type: 'model/gltf+json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = currentFile.name.replace(/\.(step|stp)$/i, '') + '.gltf';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        showMessage('glTF exported successfully!', 'success');
                    } catch (e) {
                        console.error('Error reading glTF file:', e);
                        showMessage('Export failed', 'error');
                    }
                } else {
                    showMessage('Failed to export glTF', 'error');
                }
            }
        } catch (error) {
            console.error('Error exporting glTF:', error);
            showMessage('Failed to export glTF: ' + error.message, 'error');
        } finally {
            showLoading(false);
        }
    }

    // Helper functions
    function setupDragAndDrop() {
        const uploadSection = document.getElementById('uploadSection');
        
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (isValidSTEPFile(file)) {
                    currentFile = file;
                    document.getElementById('loadBtn').disabled = false;
                    showMessage(`File selected: ${file.name}`, 'success');
                    resetUI();
                }
            }
        });
    }

    function readFileAsArrayBuffer(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = reject;
            reader.readAsArrayBuffer(file);
        });
    }

    function toggleMeasurement() {
        measurementMode = !measurementMode;
        document.getElementById('measureBtn').classList.toggle('active');
        showMessage(measurementMode ? 'Measurement mode ON' : 'Measurement mode OFF', 'info');
    }

    function toggleWireframe() {
        if (meshObject && meshObject.material) {
            meshObject.material.wireframe = !meshObject.material.wireframe;
        }
    }

    function resetView() {
        if (camera && controls && meshObject) {
            const box = new THREE.Box3().setFromObject(meshObject);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            
            camera.position.set(
                center.x + maxDim * 1.5,
                center.y + maxDim * 1.5,
                center.z + maxDim * 1.5
            );
            camera.lookAt(center);
            controls.target.copy(center);
        }
    }

    function addMeasurementPoint(event) {
        if (!measurementMode || !renderer) return;
        
        // Implementation for measurement point selection
        // This would use raycasting to select points on the mesh
    }

    function downloadImage() {
        if (screenshotData) {
            const a = document.createElement('a');
            a.href = screenshotData;
            a.download = 'step_viewer_screenshot.png';
            a.click();
        }
    }

    function downloadSTEP() {
        if (stepCopyData) {
            const url = URL.createObjectURL(stepCopyData);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'step_file_copy.step';
            a.click();
            URL.revokeObjectURL(url);
        }
    }

    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (file && isValidSTEPFile(file)) {
            currentFile = file;
            document.getElementById('loadBtn').disabled = false;
            showMessage(`File selected: ${file.name}`, 'success');
            resetUI();
        }
    }

    function isValidSTEPFile(file) {
        const validExtensions = ['.step', '.stp'];
        const fileName = file.name.toLowerCase();
        const isValid = validExtensions.some(ext => fileName.endsWith(ext));
        
        if (!isValid) {
            showMessage('Please select a valid STEP file (.step or .stp)', 'error');
        }
        
        return isValid;
    }

    function resetUI() {
        // Reset buttons
        document.getElementById('createUCSBtn').disabled = true;
        document.getElementById('screenshotBtn').disabled = true;
        document.getElementById('saveBtn').disabled = true;
        document.getElementById('downloadImageBtn').disabled = true;
        document.getElementById('downloadSTEPBtn').disabled = true;
        document.getElementById('measureBtn').disabled = true;
        document.getElementById('wireframeBtn').disabled = true;
        document.querySelector('button[onclick="resetView()"]').disabled = true;
        document.getElementById('exportGLTFBtn').disabled = true;
        document.getElementById('exportTransformedBtn').disabled = true;
        
        // Clear data
        screenshotData = null;
        stepCopyData = null;
        
        // Hide info panel
        document.getElementById('infoPanel').style.display = 'none';
        
        // Clear 3D scene
        if (meshObject) {
            scene.remove(meshObject);
            meshObject.geometry.dispose();
            meshObject.material.dispose();
            meshObject = null;
        }
        
        // Clear measurements
        measurementLines.forEach(line => scene.remove(line));
        measurementMarkers.forEach(marker => scene.remove(marker));
        measurementLines = [];
        measurementMarkers = [];
        measurementPoints = [];
    }

    function enableViewerButtons() {
        document.getElementById('createUCSBtn').disabled = false;
        document.getElementById('screenshotBtn').disabled = false;
        document.getElementById('saveBtn').disabled = false;
        document.getElementById('measureBtn').disabled = false;
        document.getElementById('wireframeBtn').disabled = false;
        document.querySelector('button[onclick="resetView()"]').disabled = false;
        document.getElementById('exportGLTFBtn').disabled = false;
        document.getElementById('exportTransformedBtn').disabled = false;
    }

    function showMessage(message, type = 'info') {
        const messagesDiv = document.getElementById('messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;
        messageDiv.textContent = message;
        messagesDiv.appendChild(messageDiv);
        
        // Remove message after 5 seconds
        setTimeout(() => {
            if (messageDiv.parentNode) {
                messageDiv.parentNode.removeChild(messageDiv);
            }
        }, 5000);
    }

    function showLoading(show) {
        document.getElementById('loading').style.display = show ? 'block' : 'none';
    }

    function showFileInfo() {
        const infoPanel = document.getElementById('infoPanel');
        const fileInfo = document.getElementById('fileInfo');
        
        fileInfo.innerHTML = `
            <div class="info-item">
                <strong>Filename:</strong> ${currentFile.name}
            </div>
            <div class="info-item">
                <strong>File Size:</strong> ${(currentFile.size / 1024).toFixed(2)} KB
            </div>
            <div class="info-item">
                <strong>Last Modified:</strong> ${new Date(currentFile.lastModified).toLocaleString()}
            </div>
        `;
        
        infoPanel.style.display = 'block';
    }

    function showUCSInfo() {
        const ucsInfo = document.getElementById('ucsInfo');
        
        if (Module && isModuleReady) {
            try {
                const ucsInfoStr = Module.ccall('getUCSInfo', 'string', [], []);
                const bboxInfoStr = Module.ccall('getBoundingBoxInfo', 'string', [], []);
                
                ucsInfo.innerHTML = `
                    <div class="info-item">
                        <strong>UCS:</strong> ${ucsInfoStr}
                    </div>
                    <div class="info-item">
                        <strong>Bounding Box:</strong> ${bboxInfoStr}
                    </div>
                `;
            } catch (error) {
                console.error('Error getting UCS info:', error);
                ucsInfo.innerHTML = `
                    <div class="info-item">
                        <strong>UCS:</strong> Created successfully
                    </div>
                `;
            }
        }
    }
    </script>
</body>
</html>